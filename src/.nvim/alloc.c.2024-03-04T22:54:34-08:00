//#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include "alloc.h"

#define HEADER (sizeof(struct header))
//#define INCREMENT 256

/*
 * This is the header for each allocated memory used internally by the
 * allocator. The test cases use this too to get the size of the header.
 */
/*
struct header {
  uint64_t size;
  struct header *next;
};
 * */

/*
 * Allocation algorithm options
 */
//enum algs { FIRST_FIT, BEST_FIT, WORST_FIT };

/*
 * Allocation statistics. The test cases only use free_size, but other fields
 * are useful for checking the correctness of the implementation.
 */
/*
struct allocinfo {
  int free_size;
  int free_chunks;
  int largest_free_chunk_size;
  int smallest_free_chunk_size;
};
 * */

//GLOBAL VARIABLES
static int g_limit; //heap limit
enum algs g_alg; //algorithm
int called_space = 0;

//head of free blocks
struct header* free_blocks = NULL;

//HELPER FUNCTIONS
//
//
//
/*
 * alloc() allocates memory from the heap. The first argument indicates the
 * size. It returns the pointer to the newly-allocated memory. It returns NULL
 * if there is not enough space.
 */
void *alloc(int sz) {
  struct header* free_block_loc = free_blocks;
  struct header* block = NULL;
  struct header* prev = NULL;

  //FINDING FREE BLOCKS BASED OFF ALGORITHM
  enum algs opt = g_alg;
  if (opt == FIRST_FIT) {
    while (free_block_loc != NULL) {
      if (free_block_loc->size < sz)
        break;
      prev = free_block_loc;
      free_block_loc = free_block_loc->next;
    }
  }
  else if (opt == BEST_FIT) {
    int lowest = sz;
    int low;
    struct header* tmp = free_block_loc;
    while (free_block_loc != NULL) {
      low = free_block_loc->size - sz - HEADER;
      if (low < lowest && low > 0) {
        tmp = free_block_loc;
        lowest = low;
      }
      prev = free_block_loc;
      free_block_loc = free_block_loc->next;
    }
    free_block_loc = tmp;
  }
  else if (opt == WORST_FIT) { //potential issue where highest is 0
    int highest = 0;
    int high;
    struct header* tmp = free_block_loc;
    while (free_block_loc != NULL) {
      high = free_block_loc->size - sz - HEADER;
      if (high > highest) {
        tmp = free_block_loc;
        highest = high;
      }
      prev = free_block_loc;
      free_block_loc = free_block_loc->next;
    }
    free_block_loc = tmp;
  }


  //INCREMENT HEAP
  if (free_block_loc == NULL) { //no free blocks found
    if (called_space + INCREMENT <= g_limit) { //within limit
      block = sbrk(INCREMENT);
      if (block == (void*)-1)
        return NULL;
      called_space += INCREMENT;
      block->size = sz;
      block->next = NULL;

      //put remaining free block at start of free_blocks
      
      struct header* new_free_block = (struct header*)(char*)block + HEADER + sz;
      new_free_block->size = INCREMENT - HEADER - sz - HEADER; //total size - allocated (sz+HEADER) - free block HEADER
      new_free_block->next = free_blocks;
      free_blocks = new_free_block; //set as head
    }
    else { //not within limit
      return NULL;
    }
  }
  else { //free block found
    if (free_block_loc->size - sz > HEADER) { //remaining free block is > 16bytes
      //spliting free block into 2
      struct header* new_free_block = (struct header*)(char*)free_block_loc + HEADER + sz;
      new_free_block->size = free_block_loc->size - sz - HEADER;
      block = free_block_loc;
      if (prev != NULL) //free_block_loc is not head
        prev->next = new_free_block;
      else {
        new_free_block->next = free_blocks;
        free_blocks = new_free_block; //set as head
      }
      new_free_block->next = free_block_loc->next;
      block->next = NULL;
      block->size = sz;
    }
    else { //return entire free block if too small
      if (prev == NULL) //is head
        free_blocks = free_block_loc->next;
      else 
        prev->next = free_block_loc->next;

      return free_block_loc;
    }
  }
  
  return block;
}

/*
 * dealloc() frees the memory pointed to by the first argument.
 */
void dealloc(void * ptr) {
  //TOP SEARCH: iterate through LL to check if (struct header*)(char*)ptr + HEADER + ptr->size == free_block
  //if matched, ptr->size += free_block->size + HEADER, free the free_block HEADER
  struct header* free_block = free_blocks;
  struct header* tmp = ptr;
  while (free_block != NULL) {
    if (((struct header*)(char*)tmp + HEADER + ptr->size) == free_block) {
    }
  }
  //
  //BOT SEARCH; iterate through LL to check if (struct header*)(char*)free_block + HEADER + free_block->size == ptr
  //if matched, free_block->size += ptr->size + HEADER, free the ptr HEADER
  //
}

/*
 * allocopt() sets the options for the memory allocator.
 *
 * The first argument sets the algorithm. The second argument sets the size
 * limit.
 */
void allocopt(enum algs alg, int limit) {
  free_blocks = NULL;
  called_space = 0;
  g_limit = limit;
  g_alg = alg;
}

/*
 * allocinfo() returns the current statistics.
 */
struct allocinfo allocinfo(void) {
  struct allocinfo tmp = {};
  return tmp;
}
